## 概述   
线程是轻量级的进程（LWP：light weight process），在 Linux 环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。  
在一个地址空间中多个线程独享：每个线程都有属于自己的栈区，寄存器 (内核中管理的)  
在一个地址空间中多个线程共享：代码段，堆区，全局数据区，打开的文件 (文件描述符表) 都是线程共享的  
每个进程对应一个虚拟地址空间，一个进程只能抢一个 CPU 时间片  
一个地址空间中可以划分出多个线程，在有效的资源基础上，能够抢更多的 CPU 时间片  
上下文切换：进程 / 线程分时复用 CPU 时间片，在切换之前会将上一个任务的状态进行保存，下次切换回这个任务的时候，加载这个状态继续运行，任务从保存到再次加载这个过程就是一次上下文切换。  
线程更加廉价，启动速度更快，退出也快，对系统资源的冲击小  
文件 IO 操作：文件 IO 对 CPU 是使用率不高，因此可以分时复用 CPU 时间片，线程的个数 = 2 * CPU 核心数 (效率最高)  
处理复杂的算法 (主要是 CPU 进行运算，压力大)，线程的个数 = CPU 的核心数 (效率最高)  

## 创建线程
```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void* (*start_routine)(void*), void* arg);
//thread:传出参数，unsigned long,线程创建成功后会把线程ID写入到这个指针指向的内存
//const pthread_attr_t :线程的属性，NULL
//start_routine:函数指针，此函数在子线程中执行
//arg:作为实参传到start_routin到函数内部
```
运行时需要动态链接
```bash
gcc pthread_create.c -lpthread
```
子线程只执行 start_routine 函数指针(返回值必须为void* 类型)的内容
## 线程退出与回收
函数
```c
void pthread_exit(void *retval);
```
主线程退出后，子线程仍然继续执行，完毕后由操作系统回收  
当子线程退出后，多个线程公用同一个虚拟地址空间，其内部的用户区（堆栈，内存map等资源）自动消失，然后由主线程释放子线程的kernel的资源  
子线程退出后，参数返回值为void*，无法接收返回值，但可以通过**(void* retval)**，来回收返回值  
线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做 pthread_join()，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。
函数原型
```c
int pthread_join(pthread_t thread, void **retval);
//retval: 二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了 pthread_exit () 传递出的数据，如果不需要这个参数，可以指定为 NUL
```
在子线程退出的时候可以使用 pthread_exit() 的参数将数据传出，在回收这个子线程的时候可以通过 phread_join() 的第二个参数来接收子线程传递出的数据。接收数据有很多种处理方式，下面来列举:
### 通过子线程栈（不可），通过全局变量，通过主程序栈
通过函数 pthread_exit(void *retval); 可以得知，子线程退出的时候，需要将数据记录到一块内存中，通过参数传出的是存储数据的内存的地址，而不是具体数据，由因为参数是 void* 类型，所有这个万能指针可以指向任意类型的内存地址。先来看第一种方式，将子线程退出数据保存在子线程自己的栈区   
```c
// 子线程的处理代码
void* working(void* arg)
{
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
        if(i == 6)
        {
            struct Persion p;
            p.age  = 12;
            strcpy(p.name, "tom");
            p.id = 100;
            // 该函数的参数将这个地址传递给了主线程的pthread_join()
            pthread_exit(&p);//线程主动退出，在此处传数据
        }
    }
    return NULL;	// 代码执行不到这个位置就退出了，此处不通过return传数据
}
//main
    // 阻塞等待子线程退出
    void* ptr = NULL;
    // ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存
    // 这个内存地址就是pthread_exit() 参数指向的内存
    pthread_join(tid, &ptr); // ptr是指针的类型,join要求二级指针,也就是传到ptr的地址

```
此处打印的值乱码，原因是：在一个虚拟地址空间中只有1个栈，东西分配在栈区，子进程结束后就被释放了。所以可以把变量定义到全局区或堆区就行了。  
或者在主线程定义一个栈区变量，储存到主线程栈区 
## 线程分离 
在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用 pthread_join() 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。  

在线程库函数中为我们提供了线程分离函数 pthread_detach()，调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用 pthread_join() 就回收不到子线程资源了  
```c
#include <pthread.h>
// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了,但是分离后主线程退出时不会释放子线程的资源了
int pthread_detach(pthread_t thread);
```
### 其他线程函数
```c
//线程取消
int pthread_cancel(pthread_t thread);
//某些特定情况下在一个线程中杀死另一个线程，但杀死的流程是：1.A中cancelB,但B暂时死不了；只有当子线程进行系统调用时才会挂
```
关于系统调用有两种方式：  
  直接调用 Linux 系统函数  
  调用标准 C 库函数，为了实现某些功能，在 Linux 平台下标准 C 库函数会调用相关的系统函数  
```c
//在某些平台上 pthread_t 可能不是一个单纯的整形，这中情况下比较两个线程的 ID 必须要使用比较函数，函数原型如下：
int pthread_equal(pthread_t t1, pthread_t t2)   //如果两个线程 ID 相等返回非 0 值，如果不相等返回 0
```






